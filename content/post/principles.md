---
title: "Principles"
date: 2018-09-26T21:03:14+02:00
draft: true
---

- accidental vs essential complexity
- developer should be close to the business, domain and users
- Model over code
- DDD
- Testing
- Refactoring: Code-level micro refactorings, Refactoring to patterns, refactoring to a deeper model
- Isolating domain logic
- Boundaries
- breaks up naturally into a number of subproblems
- Write things down https://news.ycombinator.com/item?id=18145205
- Define clearly what is the problem and what are the constraints in the solution
- Are the goals clearly stated and explained. Do we have buy in from the team?
- Make sure that the problems we are trying to fix identified and are clearly explained
- Identify area of blurriness and unclear
- simple is not easy: https://www.infoq.com/presentations/Simple-Made-Easy

Declarative >>> Imperative. This is among the most important and broad guidelines to follow in system design.
Thinking Matters. We cut the cost/time of this implementation by 90% or more, not by coding more quickly, but by thinking more clearly. I am a fan of TDD and incremental design, but you’re quite unlikely to ever make it from a handcoded solution to this simply-add-Prolog solution that way.
The Right Tool for the Job. Learn a lot of them, don’t be the person who only has a hammer.

https://simonwillison.net/2018/Oct/4/datasette-ideas/#SQL_as_an_API_language

### DDD

- https://enterprisecraftsmanship.com/2016/07/05/growing-object-oriented-software-guided-by-tests-without-mocks/
- https://enterprisecraftsmanship.com/2016/06/15/pragmatic-unit-testing/
- https://www.pluralsight.com/authors/vladimir-khorikov
- https://enterprisecraftsmanship.com/2016/06/09/styles-of-unit-testing/
